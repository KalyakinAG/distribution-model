// Возвращает значение второго параметра в случае, если значение первого параметра NULL.
// В противном случае будет возвращено значение первого параметра
//
// Параметры:
//  ПроверяемоеЗначение  - произвольный тип - проверяемое значение
//  ВозвращаемоеЗначение - произвольный тип - возвращаемое значение, если значение ПроверяемоеЗначение есть NULL
//
// Возвращаемое значение:
//  ПроверяемоеЗначение - если его значение не NULL, ВозвращаемоеЗначение - в ином случае.
//
Функция ЕстьNull(ПроверяемоеЗначение, ВозвращаемоеЗначение) Экспорт
	Если ПроверяемоеЗначение = Null Тогда
		Возврат ВозвращаемоеЗначение;
	Иначе
		Возврат ПроверяемоеЗначение;
	КонецЕсли;
КонецФункции

Функция ЕстьПустоеЗначение(ПроверяемоеЗначение, ВозвращаемоеЗначение) Экспорт
	Если Не ЗначениеЗаполнено(ПроверяемоеЗначение) Тогда
		Возврат ВозвращаемоеЗначение;
	Иначе
		Возврат ПроверяемоеЗначение;
	КонецЕсли;
КонецФункции

// Возвращает массив в свойств. Требования к свойствам такие же как при объявлении структуры.
// 
// Параметры:
//	Значение	- Строка - свойства через запятую 
//              - Массив - возвращается в исходном массиве
// Возвращаемое значение:
//	Массив - массив свойств
//
Функция Массив(Значение) Экспорт
	ТипЗначения = ТипЗнч(Значение);
	Если ТипЗначения = Тип("Массив") Тогда
		Возврат Значение;
	КонецЕсли;
	Если ТипЗначения = Тип("Строка") И НЕ ПустаяСтрока(Значение) Тогда
		Возврат СтрРазделить(СтрЗаменить(СтрЗаменить(Значение, " ", ""), Символы.ПС, ""), ",", Ложь);
	КонецЕсли;
	Возврат Новый Массив;
КонецФункции

Функция CamelCase(Строка) Экспорт
	Состав = СтрРазделить(Строка, " ", Ложь);
	Для й = 0 По Состав.ВГраница() Цикл
		Слово = Состав[й];
		Состав[й] = ВРег(Лев(Слово, 1)) + НРег(Прав(Слово, СтрДлина(Слово) - 1));
	КонецЦикла;
	Возврат СтрСоединить(Состав, "");
КонецФункции

Функция ФорматДатаВремя(ДатаВремя) Экспорт
	СоставДаты = Новый Массив;
	СоставДаты.Добавить(Год(ДатаВремя));
	СоставДаты.Добавить(Месяц(ДатаВремя));
	СоставДаты.Добавить(День(ДатаВремя));
	Если НачалоДня(ДатаВремя) <> ДатаВремя Тогда
		СоставДаты.Добавить(Час(ДатаВремя));
		СоставДаты.Добавить(Минута(ДатаВремя));
		СоставДаты.Добавить(Секунда(ДатаВремя));
	КонецЕсли;
	Возврат СтрЗаменить("ДАТАВРЕМЯ("+СтрСоединить(СоставДаты, ",")+")", Символы.НПП, "");
КонецФункции

Функция ЭкранироватьТекст(Знач ТекстоваяСтрока) Экспорт
	ТекстоваяСтрока = СтрЗаменить(ТекстоваяСтрока, Символы.ПС, Символы.ПС+"|");
	ТекстоваяСтрока = СтрЗаменить(ТекстоваяСтрока, """", """""");
	Возврат ТекстоваяСтрока;
КонецФункции

// Возвращает эквивалент имени по значению уникального идентификатора
//
// Параметры:
//  УИД - Уникальный идентификатор - Значение уникального идентификатора
//
// Возвращаемое значение:
//   Имя - Строка, удовлетворяющая требованиям имен переменных
//
Функция ИмяПоУникальномуИдентификатору(Знач УИД = Неопределено) Экспорт
	Если УИД = Неопределено Тогда
		УИД = Новый УникальныйИдентификатор;
	КонецЕсли;
	Возврат "_" + СтрЗаменить(Строка(УИД), "-", "_");
КонецФункции

Функция ОкончаниеСтрокиПослеРазделителя(Строка, Разделитель = ".") Экспорт
	Возврат Сред(Строка, СтрНайти(Строка, Разделитель, НаправлениеПоиска.СКонца)+1);
КонецФункции

Функция НачалоСтрокиПослеРазделителя(Строка, Разделитель = ".") Экспорт
	Возврат Сред(Строка, СтрНайти(Строка, Разделитель, НаправлениеПоиска.СНачала)+1);
КонецФункции

Функция ПолучитьТекстОшибок(Ошибки, Отказ = Ложь) Экспорт
	Если Ошибки = Неопределено Тогда
		Возврат "";
	Иначе
		Отказ = Истина;
	КонецЕсли; 
	ТекстОшибок = "";
	Для каждого Ошибка Из Ошибки.СписокОшибок Цикл
		Если Ошибка.ИндексСтроки = Неопределено Тогда
			ИндексСтроки = Ошибка.НомерСтроки;
		Иначе
			ИндексСтроки = Ошибка.ИндексСтроки;
		КонецЕсли;
		
		Если Ошибки.ГруппыОшибок[Ошибка.ГруппаОшибок] <> Истина Тогда
			ТекстОшибок = ТекстОшибок + Символы.ПС + Ошибка.ТекстДляОднойОшибки;
		Иначе
			ТекстОшибок = ТекстОшибок + Символы.ПС + СтрЗаменить(Ошибка.ТекстДляНесколькихОшибок, "%1", Формат(Ошибка.НомерСтроки + 1, "ЧН=0; ЧГ="));
		КонецЕсли;
	КонецЦикла;
	ТекстОшибок = Прав(ТекстОшибок, СтрДлина(ТекстОшибок)-1);
	Возврат ТекстОшибок;
КонецФункции

// Выводит накопленные методом ДобавитьОшибкуПользователю ошибки, при этом использует нужные шаблоны текстов ошибок
// в зависимости от количества однотипных ошибок.
//
// Параметры:
//  Ошибки  - Неопределено, Структура - коллекция ошибок.
//  Отказ - Булево - устанавливается Истина, если ошибки сообщались.
//
Процедура СообщитьОшибкиПользователю(Ошибки, Отказ = Ложь, Заголовок = "", Подвал = "") Экспорт
	Если Ошибки = Неопределено Тогда
		Возврат;
	КонецЕсли;
	Если НЕ ПустаяСтрока(Заголовок) Тогда
		Отступ = "	";
		ОбщегоНазначенияСлужебныйКлиентСервер.СообщитьПользователю(Заголовок, Неопределено, "");
	Иначе
		Отступ = "";
	КонецЕсли;
	Отказ = Истина;
	Для каждого Ошибка Из Ошибки.СписокОшибок Цикл
		
		Если Ошибка.ИндексСтроки = Неопределено Тогда
			ИндексСтроки = Ошибка.НомерСтроки;
		Иначе
			ИндексСтроки = Ошибка.ИндексСтроки;
		КонецЕсли;
		
		Если Ошибки.ГруппыОшибок[Ошибка.ГруппаОшибок] <> Истина Тогда
			ОбщегоНазначенияСлужебныйКлиентСервер.СообщитьПользователю(
				Отступ + Ошибка.ТекстДляОднойОшибки,
				Неопределено,
				СтрЗаменить(Ошибка.ПолеОшибки, "%1", Формат(ИндексСтроки, "ЧН=0; ЧГ=")));
		Иначе
			ОбщегоНазначенияСлужебныйКлиентСервер.СообщитьПользователю(
				Отступ + СтрЗаменить(Ошибка.ТекстДляНесколькихОшибок, "%1", Формат(Ошибка.НомерСтроки + 1, "ЧН=0; ЧГ=")),
				Неопределено,
				СтрЗаменить(Ошибка.ПолеОшибки, "%1", Формат(ИндексСтроки, "ЧН=0; ЧГ=")));
		КонецЕсли;
	КонецЦикла;
	
	Если НЕ ПустаяСтрока(Подвал) Тогда
		ОбщегоНазначенияСлужебныйКлиентСервер.СообщитьПользователю(Подвал, Неопределено, "");
	КонецЕсли;
	
КонецПроцедуры

#Если НЕ ВебКлиент Тогда
	
Функция ОбъектВJSON(Объект, ПараметрыЗаписиJSON = Неопределено) Экспорт
	ЗаписьJSON = Новый ЗаписьJSON;
	ЗаписьJSON.УстановитьСтроку(?(ПараметрыЗаписиJSON = Неопределено, Новый ПараметрыЗаписиJSON(ПереносСтрокJSON.Авто, " ", Истина), ПараметрыЗаписиJSON));
	ЗаписатьJSON(ЗаписьJSON, Объект);
	Возврат ЗаписьJSON.Закрыть();
КонецФункции

Функция JSONВОбъект(СтрокаJSON, ПрочитатьВСоответствие = Ложь) Экспорт
	ЧтениеJSON = Новый ЧтениеJSON;
	ЧтениеJSON.УстановитьСтроку(СтрокаJSON);
	Возврат ПрочитатьJSON(ЧтениеJSON, ПрочитатьВСоответствие);
КонецФункции

#КонецЕсли
